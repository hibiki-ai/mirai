---
title: "Daemons"
vignette: >
  %\VignetteIndexEntry{Daemons}
  %\VignetteEngine{litedown::vignette}
  %\VignetteEncoding{UTF-8}
---



### 1. Local Daemons

Daemons, or persistent background processes, may be set to receive 'mirai' requests.

This is typically going to be more efficient as new processes no longer need to be created on an *ad hoc* basis.

> Daemons inherit the default system configuration and read in the relevant '.Renviron' and '.Rprofile' etc. on startup.
They also load the default packages.
To instead only load the `base` package (which cuts out more than half of R's startup time), the environment variable `R_SCRIPT_DEFAULT_PACKAGES=NULL` may be set prior to launching daemons.

#### With Dispatcher (default)

Call `daemons()` specifying the number of daemons to launch.

``` r
daemons(6)
#> [1] 6
```

The default `dispatcher = TRUE` creates a `dispatcher()` background process that connects to individual daemon processes on the local machine.
This ensures that tasks are dispatched efficiently on a first-in first-out (FIFO) basis to daemons for processing.
Tasks are queued at dispatcher and sent to a daemon as soon as it can accept the task for immediate execution.

Dispatcher uses synchronisation primitives from [`nanonext`](https://nanonext.r-lib.org), waiting upon tasks rather than polling for them at intervals.
This event-driven approach is efficient both in consuming no resources while waiting, whilst also having no latency being fully synchronised with events.

To view the current status, `status()` provides:

1. The number of active connections,
2. The URL daemons connect to, and
3. A task summary:
  - `waiting` number of tasks queued for execution at dispatcher
  - `assigned` number of tasks sent to a daemon for execution
  - `complete` number of tasks for which the result has been received (either completed or cancelled)


``` r
status()
#> $connections
#> [1] 6
#> 
#> $daemons
#> [1] "ipc:///tmp/599b5e1acc58df616ff7466d"
#> 
#> $mirai
#>  awaiting executing completed 
#>         0         0         0
```


``` r
daemons(0)
#> [1] 0
```
Set the number of daemons to zero to reset.
This reverts to the default of creating a new background process for each 'mirai' request.

#### Without Dispatcher

Alternatively, specifying `dispatcher = FALSE`, the background daemons connect directly to the host process.

``` r
daemons(6, dispatcher = FALSE)
#> [1] 6
```


This means that tasks are sent immediately in a round-robin fashion, which ensures that they are evenly-distributed amongst daemons.
This does not however guarantee optimal scheduling, as the duration of tasks cannot be known *a priori*.
As an example, tasks could be queued at a daemon behind a long-running task, whilst other daemons are idle having already completed their tasks.

The advantage of this approach is that it is resource-light and does not require an additional dispatcher process.
It is suited to working with similar-length tasks, or where concurrent tasks typically do not exceed available daemons.

Requesting the status now shows 6 connections, along with the host URL:

``` r
status()
#> $connections
#> [1] 6
#> 
#> $daemons
#> [1] "ipc:///tmp/f1fc8ba8521a62d41a1dadfc"
```

#### Everywhere

`everywhere()` may be used to evaluate an expression on all connected daemons and persist the resultant state, regardless of a daemon's 'cleanup' setting.

``` r
everywhere(library(DBI))
```
The above keeps the [`DBI`](https://dbi.r-dbi.org/) package loaded for all evaluations.
Other types of setup task may also be performed, including making a common resource available, such as a database connection:


``` r
everywhere(con <<- dbConnect(RSQLite::SQLite(), file), file = tempfile())
```
By super-assignment, the conenction 'con' will be available in the global environment of all daemon instances.
Subsequent mirai calls may then make use of 'con'.


``` r
mirai(exists("con"))[]
#> [1] TRUE
```
Disconnect from the database everywhere:


``` r
everywhere(dbDisconnect(con))
```

> Sometimes it may be necessary to evaluate an expression in the global environment of each daemon.
As mirai evaluation does not occur in the global environment itself, but one inheriting from it, an explicit call to `evalq(envir = .GlobalEnv)` achieves this.
An example use case is `box::use()` to import a module or package:


``` r
everywhere(
  evalq(
    box::use(dplyr[select], mirai[...]),
    envir = .GlobalEnv
  )
)

daemons(0)
#> [1] 0
```

#### With Method

`daemons()` has a `with()` method, which evaluates an expression with daemons created for the duration of the expression and automatically torn down upon completion.

It was originally designed for running a Shiny app with the desired number of daemons, as in the example below:


``` r
with(daemons(4), shiny::runApp(app))
```

> Note: it is assumed the app is already created.
Wrapping a call to `shiny::shinyApp()` would not work as `runApp()` is implicitly called when the app is printed, however printing occurs only after `with()` has returned, hence the app would run outside of the scope of the `with()` statement.

In the case of a Shiny app, all mirai calls will be executed before the app returns as the app itself is blocking.
In the case of other expressions, be sure to call the results (or collect the values) of all mirai within the expression to ensure that they all complete before the daemons are torn down.

If specifying a compute profile for the `daemons()` call (see below), all calls with `.compute = NULL` within the `with()` clause will default to this compute profile.

### 2. Remote Daemons

The daemons interface may also be used to send tasks for computation to remote daemon processes on the network.

Call `daemons()` specifying 'url' as a character string such as: 'tcp://10.75.32.70:5555' at which daemon processes should connect.
Alternatively, use `host_url()` to automatically construct a valid URL.
The host (or dispatcher) listens at this address, utilising a single port.

> IPv6 addresses are also supported and must be enclosed in square brackets `[]` to avoid confusion with the final colon separating the port.
For example, port 5555 on the IPv6 address `::ffff:a6f:50d` would be specified as `tcp://[::ffff:a6f:50d]:5555`.

For options on actually launching the daemons, please see the next section.

Below, calling `host_url()` without a port value uses the default of '0'.
This is a wildcard value that will automatically assigns a free ephemeral port:

``` r
daemons(url = host_url())
#> [1] 0
```
The actual assigned port may be queried at any time via `status()`:

``` r
status()
#> $connections
#> [1] 0
#> 
#> $daemons
#> [1] "tcp://10.216.58.66:51899"
#> 
#> $mirai
#>  awaiting executing completed 
#>         0         0         0
```
The number of daemons connected at any time may be dynamically scaled up or down, according to requirements.

To reset all connections and revert to default behaviour:

``` r
daemons(0)
#> [1] 0
```
Closing the connection causes all connected daemons to exit automatically. If using dispatcher, it will cause dispatcher to exit, and in turn all connected daemons when their respective connections with the dispatcher are terminated.

### 3. Launching Remote Daemons

To launch remote daemons, supply a remote launch configuration to the 'remote' argument of `daemons()`, or `launch_remote()` at any time thereafter.

There are currently 3 options for generating remote launch configurations:

1. `ssh_config()` where there is SSH access to the remote machine.
2. `cluster_config()` to use HPC cluster resource managers such as Slurm, SGE, Torque/PBS and LSF.
2. `remote_config()` for a generic, flexible method that caters for other custom launchers.

The return value of all of these functions is a simple list. This means that they may be pre-constructed, saved and re-used whenever the same configuration is required.

#### i. SSH Direct Connection

This method is appropriate for internal networks and in trusted, properly-configured environments where it is safe for your machine to accept incoming connections on certain ports.
In the examples below, the remote daemons connect back directly to port 5555 on the local machine.

In these cases, using TLS is often desirable to provide additional security to the connections.

The first example below launches 4 daemons on the machine 10.75.32.90 (using the default SSH port of 22 as this was not specified), connecting back to the host URL:

``` r
daemons(
  n = 4,
  url = host_url(tls = TRUE, port = 5555),
  remote = ssh_config("ssh://10.75.32.90")
)
```
The second example below launches one daemon on each of 10.75.32.90 and 10.75.32.91 using the custom SSH port of 222:

``` r
daemons(
  n = 1,
  url = host_url(tls = TRUE, port = 5555),
  remote = ssh_config(c("ssh://10.75.32.90:222", "ssh://10.75.32.91:222"))
)
```

#### ii. SSH Tunnelling

Use SSH tunnelling to launch daemons on any machine you are able to access via SSH, whether on the local network or the cloud.
SSH key-based authentication must already be in place, but no other configuration is required.

This provides a convenient way to launch remote daemons without them needing to directly access the host.
Firewall configurations or security policies often prevent opening a port to accept outside connections.
In these cases, SSH tunnelling creates a tunnel once the initial SSH connection is made.
For simplicity, the implementation in mirai uses the same tunnel port on both the host and daemon.

To use tunnelling, supply a URL with hostname of '127.0.0.1' to 'url' for the `daemons()` call.

- `local_url(tcp = TRUE)` does this for you.
- The default uses the wildcard port of '0', which assigns a free ephemeral port.
- Whilst convenient, there is a small possibility that this port may not be available on all daemons.
- It is hence preferable to specify a specific port that has been whitelisted for use, where possible.

For example, if `local_url(tcp = TRUE, port = 5555)` is specified, the tunnel is created using port 5555 on each machine.
The host listens to `127.0.0.1:5555` on its side, and the daemons each dial into `127.0.0.1:5555` on their own respective machines.

The below example launches 2 daemons on the remote machine 10.75.32.90 using SSH tunnelling:

``` r
daemons(
  n = 2,
  url = local_url(tcp = TRUE),
  remote = ssh_config("ssh://10.75.32.90", tunnel = TRUE)
)
```

#### iii. HPC Cluster Resource Managers

`cluster_config()` may be used to deploy daemons using a cluster resource manager / scheduler.

1. The first argument is `command`. This should be:
  + `"sbatch"` if using Slurm
  + `"qsub"` if using SGE / Torque / PBS
  + `"bsub"` if using LSF.
  
2. The second argument `options` are any options that you would normally supply in a shell script to pass to the scheduler. These are script lines typically preceded by a `#`.
```
  Slurm: "#SBATCH --job-name=mirai
          #SBATCH --mem=10G
          #SBATCH --output=job.out"
  SGE: "#$ -N mirai
        #$ -l mem_free=10G
        #$ -o job.out"
  Torque/PBS: "#PBS -N mirai
               #PBS -l mem=10gb
               #PBS -o job.out"
  LSF: "#BSUB -J mirai
        #BSUB -M 10000
        #BSUB -o job.out"
```
 - As per the above, it is fine to pass this as a character string with the options each on a new line (whitespace is automatically handled), or else by specifically using `\n` to denote a newline.
 - It is also permissible to include other shell commands, for example to change working directory.
 - For the avoidance of doubt, the initial shebang line of a script such as `"#!/bin/bash"` is not required.
 - For certain setups, a final line which loads environment modules may be needed. This would usually be of the form:
 
 ```
 module load R
 ```
 or to specify an R version:
 
 ```
 module load R/4.5.0
```

3. The third argument `rscript` defaults to `"Rscript"`, which assumes that R is on the file search path.      This may be substituted for the full path to a specific R executable, such as that returned by `file.path(R.home("bin"), "Rscript")`.

#### iv. Generic Remote Configuration

`remote_config()` provides a generic, flexible framework for running any shell command that may be used to deploy daemons.

Conceptually, this function takes an `args` argument, which must contain ".". The correctly-configured call to `daemon()` is substituted in for this ".", so that `command` is run with this as one of its arguments.

This can provide an alternative for cluster resource managers in certain cases, although `cluster_config()` provides an easier and more complete interface. Using Slurm as an example, the following uses `sbatch` to launch a daemon on the cluster, with some additional Slurm options passed via command line arguments to `sbatch`:
``` r
daemons(
  n = 2,
  url = host_url(),
  remote = remote_config(
    command = "sbatch",
    args = c("--mem 512", "-n 1", "--wrap", "."),
    rscript = file.path(R.home("bin"), "Rscript"),
    quote = TRUE
  )
)
```

#### v. Manual Deployment

As an alternative to automated launches, calling `launch_remote()` without specifying 'remote' may be used to return the shell commands for deploying daemons manually.

The printed return values may then be copy / pasted directly to a remote machine e.g. via a terminal session.

``` r
daemons(url = host_url())
#> [1] 0
launch_remote(2)
#> [1]
#> Rscript -e 'mirai::daemon("tcp://10.216.58.66:51904")'
#> 
#> [2]
#> Rscript -e 'mirai::daemon("tcp://10.216.58.66:51904")'
daemons(0)
#> [1] 0
```

### 4. TLS Secure Connections

TLS provides a robust solution for securing communications from the local machine to remote daemons.

#### Automatic Zero-configuration Default

Simply specify a secure URL using the scheme `tls+tcp://` when setting daemons, or use `host_url(tls = TRUE)`, for example:

``` r
daemons(url = host_url(tls = TRUE))
#> [1] 0
```
Single-use keys and certificates are automatically generated and configured, without requiring any further intervention.
The private key is always retained on the host machine and never transmitted.

The generated self-signed certificate is available via `launch_remote()`, where it is included as part of the shell command for manually launching a daemon on a remote machine.

``` r
launch_remote(1)
#> [1]
#> Rscript -e 'mirai::daemon("tls+tcp://10.216.58.66:51908",tls=c("-----BEGIN CERTIFICATE-----
#> MIIFPzCCAyegAwIBAgIBATANBgkqhkiG9w0BAQsFADA3MRUwEwYDVQQDDAwxMC4y
#> MTYuNTguNjYxETAPBgNVBAoMCE5hbm9uZXh0MQswCQYDVQQGEwJKUDAeFw0wMTAx
#> MDEwMDAwMDBaFw0zMDEyMzEyMzU5NTlaMDcxFTATBgNVBAMMDDEwLjIxNi41OC42
#> NjERMA8GA1UECgwITmFub25leHQxCzAJBgNVBAYTAkpQMIICIjANBgkqhkiG9w0B
#> AQEFAAOCAg8AMIICCgKCAgEAx29j3ZK17X6Cl2naOVyjkdVnhE+WdmD1LVO4lZX4
#> clluL7Dkxc2zCGkz+8KFlCqmHPI56Rb9GFU7fKV6SoJ4D4wpdZqRXiudwX9DdoEk
#> fB+iUEqcsuoy16wwLx4ekU3JkOqX1A9lWvezgBdZsD1jEK5FZBduEXP87p3/eun+
#> V2EUm1ZGzTkd65WkZJpN+0jyHoQ+piwLeQBqcNz1NHdYqM2OFAzgblQCQ1CaW6+z
#> GCFCpgpT4d5YFwqY9ZFph+/OvsdGFptKlS7MLzvyrc4uop/9NAAAl3kldCVwOkWK
#> sIYML+Og67P2rfIxsQSO3B3p8qSF8XNIp2cTGnXUGRriJKAC98hr5KViKrKZ+sqP
#> SyDOiRsx0ZVAHJu76d8rP8sAZIEThusKkyFe9Be2r1cIJZHJBMPyyRtUhlhOBqKW
#> Kl91ffbRCuWD1X4k8VCMta5lqCXnwREHTcSnkb71LscNtOmnOiSaEcj47XA/FOqc
#> Paw4UR7rAMXeUFgp651D7MVJ5sb/oQmiYOgIAzN8x3zKoOCOMS2LyHSsU6HGs1aG
#> AoJBb9al8FPXGSsKZsB3xdir06T/9365hczNQPvlY5VjHLcqyXaclRGsgdKOd5+z
#> xYDDS/kgWhL+cRRGO0whUglmbOlj+DEQw6vzLqwaKYUPV+bFfbs3FafYxtgVVRsC
#> ESkCAwEAAaNWMFQwEgYDVR0TAQH/BAgwBgEB/wIBADAdBgNVHQ4EFgQUv3V4iFqx
#> JkY86Lo0uQJKd34tvIAwHwYDVR0jBBgwFoAUv3V4iFqxJkY86Lo0uQJKd34tvIAw
#> DQYJKoZIhvcNAQELBQADggIBAExCtnmZ3fjb8YXYzIX2kfAg2jDlj8pX+Yt9KnP7
#> J/h4QAo+GIhBrG9JoD3fuyuRJiFKX2dQh0VE8RbCUxocFw7bikOsyKh5u/Wm069d
#> RLy/UeAqmrYMQbP8anZiTXwQ/b42LIY2KSO+Z91vvYF8jQode32leKTs/Ld54dnm
#> Vzp8ikmxSff0CwxdWSy/GogEU1Ac3w6xXZoZqESi+eamrXCSaAZaoGQZfC1tDQDG
#> afJS38EIyra+JoWBJkwTwuf+6ViJIZvyPG/E1vjWNV5WrbSAza9kuNFEVO9gHopD
#> 0IPLEASFUy6stuybhDHhISFEl8UfV93WKkEuCW8SWmUbVGOJC8LzeWO5lE0eDcfH
#> apW1AoElkmlW3MROGvAfVYwYVk8Nz/xKEYRdvMHFngA51oRqpHd3mghiHDR3dtNU
#> 1e0WTTdkV7N3rojLHqWN/IIMnp3Exmyb9rijVRyh4fLJCtYCXvtGM/Jr3HP8vhNM
#> CwFe466YbydQAyNjRudpz1kYkvdklfCF6y/cHtEHTJWruHSqDhHoEtiOwcVTg5tS
#> 5LpMA/t5RIuo4Rkb8OerSnJ8rPP+DfnOuJk1ci6a7RwYlm1D4DSiJc029kyF31Rv
#> iMBK8SujL95qjxXEcbIUkhkku+ob3q3wGnqlZXfGmf5q6NBsVohLPc7vEaPqm6zW
#> ZUtn
#> -----END CERTIFICATE-----
#> ",""))'
```

``` r
daemons(0)
#> [1] 0
```

#### CA Signed Certificates

As an alternative to the zero-configuration default, a certificate may also be generated via a Certificate Signing Request (CSR) to a Certificate Authority (CA).
The CA may be a public CA or internal to an organisation.

1. Generate a private key and CSR. The following resources describe how to do so:
  - using Mbed TLS: <https://mbed-tls.readthedocs.io/en/latest/kb/how-to/generate-a-certificate-request-csr/>
  - using OpenSSL: <https://www.feistyduck.com/library/openssl-cookbook/online/> (Chapter 1.2 Key and Certificate Management)

2. Provide the generated CSR to the CA for it to sign a new TLS certificate.
  - The common name (CN) of the certificate must be identical to the hostname or IP address actually used for the connection. As this is verified, it will fail if not the same.
  - The received certificate should comprise a block of cipher text between the markers `-----BEGIN CERTIFICATE-----` and `-----END CERTIFICATE-----`. Make sure to request the certificate in the PEM format. If only available in other formats, the TLS library used should usually provide conversion utilities.
  - Check also that the private key is a block of cipher text between the markers `-----BEGIN PRIVATE KEY-----` and `-----END PRIVATE KEY-----`.

3. When setting daemons, the TLS certificate and private key should be provided to the 'tls' argument of `daemons()`.
  - If the certificate and private key have been imported as character strings `cert` and `key` respectively, then the 'tls' argument may be specified as the character vector `c(cert, key)`.
  - Alternatively, the certificate may be copied to a new text file, with the private key appended, in which case the path/filename of this file may be provided to the 'tls' argument.

4. When launching daemons, the certificate chain to the CA should be supplied to the 'tls' argument of `daemon()` or `launch_remote()`.
  - The certificate chain should comprise multiple certificates, each between `-----BEGIN CERTIFICATE-----` and `-----END CERTIFICATE-----` markers. The first one should be the newly-generated TLS certificate, the same supplied to `daemons()`, and the final one should be a CA root certificate.
  - These are the only certificates required if the certificate was signed directly by a CA. If not, then the intermediate certificates should be included in a certificate chain that starts with the TLS certificate and ends with the certificate of the CA.
  - If these are concatenated together as a single character string `certchain`, then the character vector comprising this and an empty character string `c(certchain, "")` may be supplied to the relevant 'tls' argument.
  - Alternatively, if these are written to a file (and the file replicated on the remote machines), then the 'tls' argument may also be specified as a path/filename (assuming these are the same on each machine).

### 5. Compute Profiles

The `daemons()` interface also allows the specification of compute profiles for managing tasks with heterogeneous compute requirements:

- send tasks to different daemons or clusters of daemons with the appropriate specifications (in terms of CPUs / memory / GPU / accelerators etc.)
- split tasks between local and remote computation

Simply specify the argument `.compute` with a character profile name (which, if `NULL`, is 'default').
The daemons settings are saved under the named profile.

To create a 'mirai' task using a specific compute profile, specify the '.compute' argument to `mirai()`, which uses the 'default' compute profile if this is `NULL`.

Similarly, functions such as `status()`, `launch_local()` or `launch_remote()` should be specified with the desired '.compute' argument.
